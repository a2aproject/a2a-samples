## UIパフォーマンスおよびUX改善に関する改修ドキュメント

### 1. 改修概要

本改修は、デモUIアプリケーションで発生していた深刻なパフォーマンス問題と、それに伴うユーザー体験（UX）の低下を解決するために実施されました。

**主な問題点:**

*   ページの読み込みや画面遷移など、すべてのUI操作が非常に遅い。
*   自動更新機能が不安定で、UI操作を阻害することがある。
*   エージェントへのメッセージ送信後、応答を待っている間の状態が分かりにくい。

**原因の特定:**
調査の結果、これらの問題は主に、非効率なデータ取得処理と、インテリジェントではない自動更新（ポーリング）のロジックに起因することが判明しました。

**解決策:**
以下の多角的なアプローチにより、問題の根本解決を図りました。

1.  **データ取得処理の並列化**: ポーリング時に実行される複数のAPI呼び出しを、`asyncio.gather` を用いて並列化し、データ取得時間を大幅に短縮。
2.  **インテリジェントなポーリング制御**:
    *   **ページ制御**: 自動更新を会話関連ページ (`/`, `/conversation`) のみに限定。
    *   **ビジー状態制御**: エージェントからの応答を待っている間は自動更新を一時停止する「ビジー状態」を導入。
3.  **UI/UXの改善**:
    *   応答待ちの間に、入力欄の上にロードスピナーを正しく表示。
    *   自動更新のデフォルト間隔を、UIを阻害しない安定した値 (`3s`) に変更。

これらの修正により、アプリケーションの応答性を劇的に改善し、安定した自動更新機能と分かりやすいユーザー体験を両立させることができました。

### 2. 全体像：問題と解決策

今回の改修の核心は、「非効率な直列処理」を「効率的な並列処理」に置き換え、さらに「無駄な処理」を徹底的に排除した点にあります。

#### ボトルネック：非効率なデータ取得（ウェイターの例え）

当初のアプリケーションは、自動更新のたびに、以下のような複数のデータ取得処理を**一つずつ順番に**行っていました。

1.  会話リストの取得 (`ListConversations`)
2.  タスクリストの取得 (`GetTasks`)
3.  処理中メッセージの取得 (`GetProcessingMessages`)
4.  ...など

これは、レストランでウェイターが客の注文を一人ずつ聞き、その料理が提供されるまで次の客の注文を取りに行かないのと同じです。キッチンが調理している間、ウェイターはただ待っているだけで、非常に非効率です。

**解決策**として `asyncio.gather` を導入しました。これにより、ウェイターが全員の注文を一度に聞いてキッチンに渡し、すべての料理が揃うのを待つように、すべてのデータ取得リクエストを**同時に開始**し、まとめて結果を受け取るように変更しました。これにより、データ取得の合計時間は、個々の処理時間の中で最も長いもの一つ分にまで短縮されました。

#### 陥っていたデッドロック：自動更新の矛盾

改修の過程で、「応答待ちの間は自動更新を止めよう」と試みた結果、**デッドロック（行き詰まり）**が発生しました。

*   **問題**:
    1.  メッセージを送信すると、「応答待ち」フラグがONになる。
    2.  このフラグがONになると、自動更新が停止する。
    3.  しかし、「応答待ち」フラグをOFFに戻す処理は、自動更新の中に含まれていた。
*   **結果**: 自動更新が止まったため、「応答待ち」フラグをOFFに戻す処理が永遠に実行されず、ロード表示が消えなくなってしまいました。

**解決策**として、このロジックを修正しました。「応答待ち」フラグは、自動更新を止めるためではなく、**UI（入力欄の無効化やスピナー表示）を制御するためだけ**に使うように役割を限定しました。自動更新は裏で動き続け、応答を検知してフラグをOFFに戻す、という正しい役割分担を実現しました。

### 3. 各ファイルの改修内容

#### `state/host_agent_service.py`

*   **改修内容**:
    *   `UpdateAppState` 関数内の `ListConversations`, `GetTasks` などの非同期API呼び出しを、`asyncio.gather` を使って並列で実行するように変更しました。
    *   エージェントからの応答（新しいメッセージ）を検知した場合に、`AppState.is_processing_message` フラグを `False` に設定するロジックを追加しました。
*   **理由**: アプリケーション全体のパフォーマンスボトルネックとなっていたデータ取得処理を高速化するため。また、ロード状態を正しく完了させるため。

#### `state/state.py`

*   **改修内容**:
    *   `AppState` に `is_processing_message: bool = False` を追加しました。
    *   `AppState` に `current_page_path: str = '/'` を追加しました。
    *   `polling_interval` のデフォルト値を `1` から `3` に変更しました。
*   **理由**: エージェントへの応答待ち（ビジー状態）を管理するため。条件付きポーリングのために現在のページパスを管理するため。より安定したUI動作のためのデフォルト値変更。

#### `components/page_scaffold.py`

*   **改修内容**:
    *   `async_poller`（自動更新コンポーネント）の呼び出しを、`if app_state.current_page_path in ['/', '/conversation']:` という条件で囲みました。
*   **理由**: 自動更新を会話関連ページのみに限定し、他のページ（設定画面など）での不要な負荷をなくすため。

#### `components/conversation.py`

*   **改修内容**:
    *   `on_submit`（メッセージ送信）関数の開始時に `AppState.is_processing_message` を `True` に設定するように変更しました。
    *   `is_processing_message` が `True` の場合に、入力欄が無効化され、`me.progress_spinner` が表示されるようにUIロジックを修正しました。
    *   `NameError` を引き起こしていた古い関数参照を修正し、コード全体をクリーンアップしました。
*   **理由**: メッセージ送信時に「ビジー状態」を開始し、ユーザーにロード中であることを視覚的に伝え、二重送信を防ぐため。バグ修正とコードの可読性向上のため。

#### `components/poller.py`

*   **改修内容**:
    *   ポーリング間隔の選択肢から `1s` を削除し、`3s` を追加しました。
    *   `on_change`（間隔変更時の処理）を修正し、間隔変更中に一時的にポーリングが停止するようにしました。
*   **理由**: UIの表示を新しいデフォルト値に合わせるため。ユーザーがポーリング間隔を変更する操作自体が、高頻度のポーリングによって阻害されるのを防ぐため。

#### `main.py`

*   **改修内容**:
    *   すべてのページで共通だった `on_load` 関数を、ページごとに個別の `on_load_xxx` 関数（例: `on_load_home`）に分割しました。
    *   各 `on_load_xxx` 関数の中で、`AppState.current_page_path` に現在のページのパス（例: `'/'`）を設定するようにしました。
*   **理由**: `page_scaffold.py` での条件付きポーリングを実現するために、アプリケーションの状態として現在のページパスを正確に管理する必要があったため。

### 4. 最終的な動作

上記の一連の改修により、アプリケーションは以下の通り、安定的かつ高性能に動作します。

*   **UIの応答性**: すべてのUI操作がスムーズに応答します。
*   **インテリジェントな自動更新**:
    *   会話ページでのみ自動更新が実行されます。
    *   エージェントからの応答を待っている間は、自動更新が一時停止します。
    *   デフォルトの間隔は3秒で、UIから安全に変更・無効化できます。
*   **明確なロード表示**: メッセージ送信中は、入力欄が無効になり、応答が返ると同時にロードスピナーが表示されます。
